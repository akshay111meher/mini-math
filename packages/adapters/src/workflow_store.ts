import {
  ListOptions,
  ListResult,
  WorkflowCoreType,
  WorkflowDef,
  WorkflowStore,
} from '@mini-math/workflow'

import { sql, eq } from 'drizzle-orm'
import { drizzle, NodePgDatabase } from 'drizzle-orm/node-postgres'
import { Pool } from 'pg'
import * as schema from './db/schema/workflow.js'
import { workflows } from './db/schema/workflow.js'

type Db = NodePgDatabase<typeof schema>

export class PostgresWorkflowstore extends WorkflowStore {
  private db!: Db
  private pool!: Pool

  private readonly postgresUrl: string

  constructor(postgresUrl: string) {
    super()
    this.postgresUrl = postgresUrl
  }

  protected async initialize(): Promise<void> {
    // 1. Create PG pool
    this.pool = new Pool({
      connectionString: this.postgresUrl,
    })

    // 2. Wrap pool in Drizzle
    this.db = drizzle(this.pool, {
      schema,
    })

    // 3. Optional sanity check – ensure DB is reachable
    await this.db.execute(sql`select 1`)
  }

  protected async _create(
    workflowId: string,
    core: WorkflowCoreType,
    owner: string,
  ): Promise<WorkflowDef> {
    const insert = coreToInsert(workflowId, core, owner)

    const [row] = await this.db.insert(workflows).values(insert).returning()

    return rowToDef(row)
  }
  protected async _get(workflowId: string): Promise<WorkflowDef> {
    const row = await this.db.query.workflows.findFirst({
      where: eq(workflows.id, workflowId),
    })

    if (!row) {
      // Let the abstract base handle how "not found" is surfaced,
      // or throw here if that's the contract.
      throw new Error(`Workflow ${workflowId} not found`)
    }

    return rowToDef(row)
  }
  protected async _update(workflowId: string, patch: Partial<WorkflowDef>): Promise<WorkflowDef> {
    const update: Partial<WorkflowInsert> = {}

    if ('owner' in patch && patch.owner !== undefined) {
      update.owner = patch.owner
    }
    if ('name' in patch) {
      update.name = patch.name ?? null
    }
    if ('version' in patch && patch.version !== undefined) {
      update.version = patch.version
    }
    if ('nodes' in patch && patch.nodes !== undefined) {
      update.nodes = patch.nodes
    }
    if ('edges' in patch && patch.edges !== undefined) {
      update.edges = patch.edges
    }
    if ('entry' in patch && patch.entry !== undefined) {
      update.entry = patch.entry
    }
    if ('globalState' in patch) {
      update.globalState = patch.globalState === undefined ? null : (patch.globalState as unknown)
    }

    if (Object.keys(update).length === 0) {
      // nothing to update, just return the current value
      return this._get(workflowId)
    }

    const [row] = await this.db
      .update(workflows)
      .set({
        ...update,
        // DB-level timestamp
        updatedAt: sql`now()`,
      })
      .where(eq(workflows.id, workflowId))
      .returning()

    if (!row) {
      throw new Error(`Workflow ${workflowId} not found`)
    }

    return rowToDef(row)
  }
  protected async _exists(workflowId: string): Promise<boolean> {
    const row = await this.db
      .select({ id: workflows.id })
      .from(workflows)
      .where(eq(workflows.id, workflowId))
      .limit(1)

    return row.length > 0
  }
  protected async _delete(workflowId: string): Promise<void> {
    await this.db.delete(workflows).where(eq(workflows.id, workflowId))
  }
  protected async _list(options?: ListOptions): Promise<ListResult> {
    const limit = options?.limit ?? 50

    // simple cursor = numeric offset, encoded as string
    const offset = options?.cursor ? Number(options.cursor) : 0

    // main page query
    const itemsQuery = this.db
      .select()
      .from(workflows)
      .limit(limit)
      .offset(offset)
      .orderBy(workflows.createdAt)

    // total count (for pagination / nextCursor decision)
    const countQuery = this.db.select({ count: sql<number>`count(*)` }).from(workflows)

    const [rows, [countRow]] = await Promise.all([itemsQuery, countQuery])

    const items = rows.map(rowToDef)
    const total = Number(countRow.count)

    const nextOffset = offset + limit
    const nextCursor = nextOffset < total ? String(nextOffset) : undefined

    const result: ListResult = {
      items,
      // if ListResult doesn’t require nextCursor, this is still fine
      nextCursor,
    }

    return result
  }
  protected async _replace(workflowId: string, def: WorkflowDef): Promise<WorkflowDef> {
    const insert: WorkflowInsert = {
      id: workflowId,
      owner: def.owner,
      name: def.name ?? null,
      version: def.version,
      nodes: def.nodes,
      edges: def.edges,
      entry: def.entry,
      globalState: def.globalState === undefined ? null : (def.globalState as unknown),
    }

    const [row] = await this.db
      .insert(workflows)
      .values(insert)
      .onConflictDoUpdate({
        target: workflows.id,
        set: {
          owner: insert.owner,
          name: insert.name,
          version: insert.version,
          nodes: insert.nodes,
          edges: insert.edges,
          entry: insert.entry,
          globalState: insert.globalState,
          updatedAt: sql`now()`,
        },
      })
      .returning()

    return rowToDef(row)
  }
}

type WorkflowInsert = typeof workflows.$inferInsert
type WorkflowRow = typeof workflows.$inferSelect

function coreToInsert(workflowId: string, core: WorkflowCoreType, owner: string): WorkflowInsert {
  return {
    id: workflowId,
    owner,
    name: core.name ?? null,
    version: core.version,
    nodes: core.nodes,
    edges: core.edges,
    entry: core.entry,
    globalState: core.globalState === undefined ? null : (core.globalState as unknown),
  }
}

function rowToDef(row: WorkflowRow): WorkflowDef {
  // Adjust this mapping if WorkflowDef has different shape
  return {
    id: row.id,
    owner: row.owner,
    name: row.name ?? undefined,
    version: row.version,
    nodes: row.nodes as WorkflowDef['nodes'],
    edges: row.edges as WorkflowDef['edges'],
    entry: row.entry as WorkflowDef['entry'],
    globalState:
      row.globalState === null || row.globalState === undefined
        ? undefined
        : (row.globalState as WorkflowDef['globalState']),
    // if WorkflowDef carries timestamps, uncomment:
    createdAt: row.createdAt,
    updatedAt: row.updatedAt,
  } as WorkflowDef
}
